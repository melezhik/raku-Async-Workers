use v6.d;
use Test;
use Async::Workers;
use Async::Msg;

plan 4;

subtest "Basics" => {
    plan 6;
    my $w = Async::Workers.new(:max-workers(10));

    is $w.workers, 0, "No workers on start";

    $w.do-async: {pass "Async job"};

    sleep .1;
    is $w.workers, 10, "Vivified all workers on demand";

    $w.workers(15);

    sleep .1;
    is $w.workers, 15, "Started 5 additional";

    $w.workers(12);

    sleep .1;
    is $w.workers, 12, "Shut down 3 workers";

    $w.shutdown;

    sleep .1;
    is $w.workers, 0, "Shut down all workers";
}

subtest "Limited queue" => {
    plan 10;
    my @w;
    for 1..10 {
        subtest "Queue limits $_", {
            plan 3;
            my $w = Async::Workers.new(max-workers => 1, lo-threshold => 10, hi-threshold => 20);
            # @w.push: $w;

            my atomicint $fulls = 0;
            my atomicint $empties = 0;
            my atomicint $lows = 0;

            $w.on_msg: -> $msg {
                if $msg ~~ Async::Msg::Queue {
                    given $msg.status {
                        when QFull {
                            $fulls⚛++;
                        }
                        when QEmpty {
                            $empties⚛++;
                        }
                        when QLow {
                            $lows⚛++;
                        }
                    }
                }
            };

            for 1...50 -> $cnt {
                $w.do-async: {
                    sleep .01;
                };
            }

            $w.shutdown;

            is $fulls, 4, "queue on high threshold";
            is $lows, 4, "queue on low threshold";
            is $empties, 1, "queue empty";
        }
    }
}

subtest "Await Workers" => {
    plan 5;

    my $w = Async::Workers.new;

    my $awaited = False;

    await Promise.anyof:
        Promise.in(.1),
        start {
            await $w;
            $awaited  = True;
        };

    ok $awaited, "await on fresh state";

    my atomicint $counter ⚛= 0;
    my &code = {
        sleep .1.rand;
        $counter⚛++;
    }

    for 1..20 {
        $w.do-async: &code
    }

    $awaited = False;
    await Promise.anyof:
        Promise.in(10),
        start {
            await $w;
            $awaited = True;
        };

    ok $awaited, "await for non-finished queue";

    is $counter, 20, "all workers completed";

    my $w1 = Async::Workers.new(:max-workers(5));
    my $w2 = Async::Workers.new(:max-workers(10));

    $awaited = False;
    $counter ⚛= 0;

    for 1..20 {
        $w1.do-async: &code;
        $w2.do-async: &code;
    }

    await Promise.anyof:
        Promise.in(20),
        start {
            await $w1, $w2;
            $awaited = True;
        };

    ok $awaited, "await for non-finished queue on two managers";

    is $counter, 40, "all workers of both managers completed";
}

subtest "Stop Worker", {
    plan 1;

    my $w = Async::Workers.new;

    my atomicint $steps = 0;
    $w.do-async: {
        $steps++;
        stop-worker;
        flunk "must not be here";
        $steps++; # Must not reach this point.
    }

    $w.shutdown;
    await $w;

    is $steps, 1, "a worker has been stopped";
}

done-testing;
